/* Generated by re2c 3.0 on Sun Jun  4 13:33:51 2023 */
#line 1 "parse_u32_blocks.re"
// re2csharp $INPUT -o $OUTPUT -i
using System;
using System.Text;

class U32Parser
{
	static uint Parse(byte[] str) {
		int cur = 0;
		int mar = 0;
		ulong result = 0;
		ulong u32Limit = (ulong)UInt32.MaxValue + 1;
	 	void Add(ulong numbase, byte offset) {
			result = result * numbase + (ulong)(str[cur-1] - offset);
			if (result >= u32Limit) {
				Console.WriteLine("overflow");
				result = u32Limit;
			}
		}


	
#line 25 "parse_u32_blocks.cs"
{
	byte yych;
	yych = str[cur];
	switch (yych) {
		case 0x30: goto yy2;
		case >= 0x31 and <= 0x39: goto yy4;
		default: goto yy1;
	}
yy1:
	cur += 1;
#line 36 "parse_u32_blocks.re"
	{ goto err; }
#line 38 "parse_u32_blocks.cs"
yy2:
	cur += 1;
	mar = cur;
	yych = str[cur];
	switch (yych) {
		case 0x42:
		case 0x62: goto yy5;
		case 0x58:
		case 0x78: goto yy7;
		default: goto yy3;
	}
yy3:
#line 33 "parse_u32_blocks.re"
	{ goto oct; }
#line 53 "parse_u32_blocks.cs"
yy4:
	cur += 1;
	cur += -1;
#line 34 "parse_u32_blocks.re"
	{ goto dec; }
#line 59 "parse_u32_blocks.cs"
yy5:
	cur += 1;
	yych = str[cur];
	switch (yych) {
		case >= 0x30 and <= 0x31: goto yy8;
		default: goto yy6;
	}
yy6:
	cur = mar;
	goto yy3;
yy7:
	cur += 1;
	yych = str[cur];
	switch (yych) {
		case >= 0x30 and <= 0x39:
		case >= 0x41 and <= 0x46:
		case >= 0x61 and <= 0x66: goto yy9;
		default: goto yy6;
	}
yy8:
	cur += 1;
	cur += -1;
#line 32 "parse_u32_blocks.re"
	{ goto bin; }
#line 84 "parse_u32_blocks.cs"
yy9:
	cur += 1;
	cur += -1;
#line 35 "parse_u32_blocks.re"
	{ goto hex; }
#line 90 "parse_u32_blocks.cs"
}
#line 37 "parse_u32_blocks.re"

bin:
	
#line 96 "parse_u32_blocks.cs"
{
	byte yych;
	yych = str[cur];
	switch (yych) {
		case 0x00: goto yy11;
		case >= 0x30 and <= 0x31: goto yy13;
		default: goto yy12;
	}
yy11:
	cur += 1;
#line 40 "parse_u32_blocks.re"
	{ goto end; }
#line 109 "parse_u32_blocks.cs"
yy12:
	cur += 1;
#line 42 "parse_u32_blocks.re"
	{ goto err; }
#line 114 "parse_u32_blocks.cs"
yy13:
	cur += 1;
#line 41 "parse_u32_blocks.re"
	{ Add(2, (byte)'0'); goto bin; }
#line 119 "parse_u32_blocks.cs"
}
#line 43 "parse_u32_blocks.re"

oct:
	
#line 125 "parse_u32_blocks.cs"
{
	byte yych;
	yych = str[cur];
	switch (yych) {
		case 0x00: goto yy15;
		case >= 0x30 and <= 0x37: goto yy17;
		default: goto yy16;
	}
yy15:
	cur += 1;
#line 46 "parse_u32_blocks.re"
	{ goto end; }
#line 138 "parse_u32_blocks.cs"
yy16:
	cur += 1;
#line 48 "parse_u32_blocks.re"
	{ goto err; }
#line 143 "parse_u32_blocks.cs"
yy17:
	cur += 1;
#line 47 "parse_u32_blocks.re"
	{ Add(8, (byte)'0'); goto oct; }
#line 148 "parse_u32_blocks.cs"
}
#line 49 "parse_u32_blocks.re"

dec:
	
#line 154 "parse_u32_blocks.cs"
{
	byte yych;
	yych = str[cur];
	switch (yych) {
		case 0x00: goto yy19;
		case >= 0x30 and <= 0x39: goto yy21;
		default: goto yy20;
	}
yy19:
	cur += 1;
#line 52 "parse_u32_blocks.re"
	{ goto end; }
#line 167 "parse_u32_blocks.cs"
yy20:
	cur += 1;
#line 54 "parse_u32_blocks.re"
	{ goto err; }
#line 172 "parse_u32_blocks.cs"
yy21:
	cur += 1;
#line 53 "parse_u32_blocks.re"
	{ Add(10, (byte)'0'); goto dec; }
#line 177 "parse_u32_blocks.cs"
}
#line 55 "parse_u32_blocks.re"

hex:
	
#line 183 "parse_u32_blocks.cs"
{
	byte yych;
	yych = str[cur];
	switch (yych) {
		case 0x00: goto yy23;
		case >= 0x30 and <= 0x39: goto yy25;
		case >= 0x41 and <= 0x46: goto yy26;
		case >= 0x61 and <= 0x66: goto yy27;
		default: goto yy24;
	}
yy23:
	cur += 1;
#line 58 "parse_u32_blocks.re"
	{ goto end; }
#line 198 "parse_u32_blocks.cs"
yy24:
	cur += 1;
#line 62 "parse_u32_blocks.re"
	{ goto err; }
#line 203 "parse_u32_blocks.cs"
yy25:
	cur += 1;
#line 59 "parse_u32_blocks.re"
	{ Add(16, (byte)'0');    goto hex; }
#line 208 "parse_u32_blocks.cs"
yy26:
	cur += 1;
#line 61 "parse_u32_blocks.re"
	{ Add(16, (byte)'A'-10); goto hex; }
#line 213 "parse_u32_blocks.cs"
yy27:
	cur += 1;
#line 60 "parse_u32_blocks.re"
	{ Add(16, (byte)'a'-10); goto hex; }
#line 218 "parse_u32_blocks.cs"
}
#line 63 "parse_u32_blocks.re"

end:
	if (result < u32Limit) {
		return (uint)result;
	} else {
		return 0;
	}
err:
	return 0;
}

public static void Main() {
	void Test(uint num, string str, object dmp) {
		var b = Encoding.UTF8.GetBytes(str);
		var n = Parse(b);
		if (n != num) {
			throw new ApplicationException(String.Format("error: {0} is not {1}", n, num));
		}
	}
	Test(1234567890, "1234567890\0", null);
	Test(13, "0b1101\0", null);
	Test(0x7fe, "0x007Fe\0", null);
	Test(420, "0644\0", null);
	Test(0, "9999999999\0", null); //eOverflow)
	Test(0, "123??\0", null); //eSyntax)
}
}